<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Device Keyboard (WebSerial) - GitHub Pages Template</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --root-bg:#0b0e10; --text:#f5f6f7;
      --kbd-border:#111315; --kbd-bg:#0f1416;
      --key-zero:#232628; --key-selected:#1309AA; --key-highlight:#ff8c42;
      --val-color:#5e76ff;
    }
    body{background:var(--root-bg); color:var(--text); font-family: "Helvetica", Arial, sans-serif; margin:16px;}
    h1 {font-size:1.2rem; margin-bottom:8px;}
    .topbar{display:flex;align-items:center;gap:8px;margin-bottom:12px;flex-wrap:wrap;}
    select,input[type="text"]{background:#111316;color:var(--text);border:1px solid #222;padding:6px;border-radius:4px;}
    button{background:#2c3e50;color:#fff;border:0;padding:8px 12px;border-radius:6px;cursor:pointer;}
    button.primary{background:#16a085;}
    button.danger{background:#c0392b;}
    button:disabled{opacity:0.5;cursor:not-allowed;}
    .kbd-border{background: linear-gradient(180deg,#111316,#0c0f11); padding:10px; border-radius:10px; border:3px solid var(--kbd-border); display:inline-block;}
    #keyboard{background:var(--kbd-bg); padding:14px; border-radius:6px; display:block;}
    .kb-row{display:flex; margin-bottom:10px;}
    .kb-key{display:flex;flex-direction:column;justify-content:center;align-items:center;border-radius:8px;margin-right:8px;padding:6px; background:var(--key-zero); cursor:pointer; user-select:none; min-width:36px; box-shadow: 0 2px 0 rgba(0,0,0,0.4); box-sizing: border-box;}
    .kb-key .label{font-weight:bold; text-align:center; white-space:pre-wrap;}
    .kb-key .val{color:var(--val-color);font-size:12px;margin-top:6px;}
    .kb-key.selected{background:var(--key-selected);}
    .kb-key.highlight{background:var(--key-highlight) !important;}
    #controls{display:flex;align-items:center; gap:8px; margin-top:12px; flex-wrap:wrap;}
    #selectionInfo{min-width:160px;}
    #slider{width:420px}
    .log{background:#0f1416;border:1px solid #222;height:220px;overflow:auto;padding:8px;border-radius:6px;color:#bcd;margin-top:12px;}
    .status{margin-left:8px;color:#bcd;}
    @media(max-width:900px){ #slider{width:220px} .kb-key{min-width:44px}}
  </style>
</head>
<body>
  <h1>Device Keyboard (WebSerial)</h1>

  <div class="topbar">
    <button id="btnConnect" class="primary">Connect</button>
    <button id="btnDisconnect" disabled>Disconnect</button>
    <label>Baud: <input id="baud" type="text" value="115200" style="width:100px" /></label>
    <span id="portInfo" class="status">Port: -</span>
    <span id="status" class="status">Status: Not connected</span>
  </div>

  <!-- keyboard frame -->
  <div class="kbd-border">
    <div id="keyboard"></div>
  </div>

  <div id="controls">
    <div id="selectionInfo"></div>
    <input id="slider" type="range" min="0" max="100" value="0" disabled />
    <button id="btnClear">選択解除</button>
    <button id="btnRun" class="primary">決定</button>
    <button id="btnStop" class="danger" disabled>停止</button>
  </div>

  <pre class="log" id="log"></pre>

<script>
/* ===== configuration ===== */
const ASSIGN_KEYS = ['Esc','1','2','3','4','5','Tab','Q','W','E','R','T',
  'Caps','A','S','D','F','G','ShiftL','Z','X','C','V','CtrlL','Win','AltL','Space'];

const KEYBOARD_LAYOUT = [
    {
        keys: [
            {'label': 'Esc', 'width': 1},
            {'label': '1', 'width': 1},
            {'label': '2', 'width': 1},
            {'label': '3', 'width': 1},
            {'label': '4', 'width': 1},
            {'label': '5', 'width': 1},
            {'label': '6', 'width': 1},
            {'label': '7', 'width': 1},
            {'label': '8', 'width': 1},
            {'label': '9', 'width': 1},
            {'label': '0', 'width': 1},
            {'label': '-', 'width': 1},
            {'label': '=', 'width': 1},
            {'label': 'Backspace', 'width': 2},
        ]
    },
    {
        keys: [
            {'label': 'Tab', 'width': 1.5},
            {'label': 'Q', 'width': 1},
            {'label': 'W', 'width': 1},
            {'label': 'E', 'width': 1},
            {'label': 'R', 'width': 1},
            {'label': 'T', 'width': 1},
            {'label': 'Y', 'width': 1},
            {'label': 'U', 'width': 1},
            {'label': 'I', 'width': 1},
            {'label': 'O', 'width': 1},
            {'label': 'P', 'width': 1},
            {'label': '[', 'width': 1},
            {'label': ']', 'width': 1},
            {'label': '\\', 'width': 1.5}
        ]
    },
    {
        keys: [
            {'label': 'Caps', 'width': 1.75},
            {'label': 'A', 'width': 1},
            {'label': 'S', 'width': 1},
            {'label': 'D', 'width': 1},
            {'label': 'F', 'width': 1},
            {'label': 'G', 'width': 1},
            {'label': 'H', 'width': 1},
            {'label': 'J', 'width': 1},
            {'label': 'K', 'width': 1},
            {'label': 'L', 'width': 1},
            {'label': ';', 'width': 1},
            {'label': '\'', 'width': 1},
            {'label': 'Enter', 'width': 2.25}
        ]
    },
    {
        keys: [
            {'label': 'ShiftL', 'width': 2.25},
            {'label': 'Z', 'width': 1},
            {'label': 'X', 'width': 1},
            {'label': 'C', 'width': 1},
            {'label': 'V', 'width': 1},
            {'label': 'B', 'width': 1},
            {'label': 'N', 'width': 1},
            {'label': 'M', 'width': 1},
            {'label': ',', 'width': 1},
            {'label': '.', 'width': 1},
            {'label': '/', 'width': 1},
            {'label': 'ShiftR', 'width': 2.75}
        ]
    },
    {
        keys: [
            {'label': 'CtrlL', 'width': 1.25},
            {'label': 'Win', 'width': 1.25},
            {'label': 'AltL', 'width': 1.25},
            {'label': 'Space', 'width': 6.25},
            {'label': 'AltR', 'width': 1.25},
            {'label': 'Menu', 'width': 1.25},
            {'label': 'Fn', 'width': 1.25},
            {'label': 'CtrlR', 'width': 1.25}
        ]
    }
];

const KEY_UNIT = 64, KEY_HEIGHT = 80, KEY_SPACING = 8;
const STEPS_PER_REV = 200, MIN_STEP_DELAY = 0.002, MAX_STEP_DELAY = 0.020;

/* ===== state & references ===== */
let N_DEVICES = 0;
assignDevicesByList(KEYBOARD_LAYOUT, ASSIGN_KEYS);
for (const row of KEYBOARD_LAYOUT) for (const k of row.keys) if (k.device!==undefined) N_DEVICES = Math.max(N_DEVICES, k.device+1);

let deviceValues = new Array(N_DEVICES).fill(0);

const KEYBOARD_EL = document.getElementById('keyboard');
const logEl = document.getElementById('log'), statusEl = document.getElementById('status'), portInfoEl = document.getElementById('portInfo');
const btnConnect = document.getElementById('btnConnect'), btnDisconnect = document.getElementById('btnDisconnect');
const baudInput = document.getElementById('baud'), slider = document.getElementById('slider');
const selectionInfoEl = document.getElementById('selectionInfo'), btnClear = document.getElementById('btnClear');
const btnRun = document.getElementById('btnRun'), btnStop = document.getElementById('btnStop');

let selected = new Set();
let labelToKey = {}, labelToElement = {};
let currentDevice = -1;
let running = false, stopRequested = false;

/* vendor map for friendly name */
const VENDOR_MAP = {
  0x2341: 'Arduino (official)',
  0x1A86: 'CH340 (clone)',
  0x0403: 'FTDI',
  0x067B: 'Prolific (PL2303)',
  0x10C4: 'Silicon Labs (CP210x)'
};

/* ===== helper functions ===== */
function log(msg){ logEl.textContent += `[${(new Date()).toLocaleTimeString()}] ${msg}\n`; logEl.scrollTop = logEl.scrollHeight; }

function assignDevicesByList(layout, assign_keys){
  for (const r of layout) for (const k of r.keys) delete k.device;
  const allLabels = new Set();
  for (const row of layout) for (const k of row.keys) allLabels.add(k.label);
  const seen = new Set(), seq = [];
  for (const k of assign_keys){
    if (seen.has(k)) continue;
    seen.add(k);
    if (allLabels.has(k)) seq.push(k);
  }
  for (let i=0;i<seq.length;i++){
    const lbl = seq[i];
    let assigned=false;
    for (const row of layout){
      for (const key of row.keys){
        if (key.label === lbl){ key.device = i; assigned=true; break; }
      }
      if (assigned) break;
    }
  }
}

function buildKeyboard(){
  KEYBOARD_EL.innerHTML=''; labelToKey={}; labelToElement={};
  for (const row of KEYBOARD_LAYOUT){
    const rowDiv = document.createElement('div'); rowDiv.className='kb-row';

    row.keys.forEach((key, idx)=>{
      // 1) 小数px維持（roundしない）
      const widthPx = (key.width || 1) * KEY_UNIT - KEY_SPACING;

      const el = document.createElement('div');
      el.className = 'kb-key';
      el.style.width = widthPx + 'px';
      el.style.height = KEY_HEIGHT + 'px';

      // 2) 行末だけ margin-right を 0 に
      el.style.marginRight = (idx === row.keys.length - 1) ? '0px' : KEY_SPACING + 'px';

      const lbl = document.createElement('div'); lbl.className='label'; lbl.textContent = key.label;
      const val = document.createElement('div'); val.className='val';
      val.textContent = (key.device!==undefined ? deviceValues[key.device] : '');

      el.appendChild(lbl); el.appendChild(val);
      el.addEventListener('click', ()=>onKeyClicked(key.label));
      rowDiv.appendChild(el);

      labelToKey[key.label] = key;
      labelToElement[key.label] = {el, lbl, val};
      updateKeyBg(key.label);
    });

    KEYBOARD_EL.appendChild(rowDiv);
  }
}

function updateKeyBg(label){
  const k = labelToKey[label], m = labelToElement[label];
  if (!m) return;
  if (!k || k.device===undefined){ m.el.style.background = 'var(--kbd-bg)'; m.val.textContent=''; return; }
  const di = k.device;
  if (currentDevice===di) m.el.classList.add('highlight'); else m.el.classList.remove('highlight');
  if (selected.has(di)) m.el.classList.add('selected'); else m.el.classList.remove('selected');
  m.val.textContent = String(deviceValues[di] || 0);
}

function onKeyClicked(label){
  const key = labelToKey[label];
  if (!key || key.device===undefined){ log('キーはデバイス割当なし: '+label); return; }
  if (running){ log('動作中は選択変更不可'); return; }

  const di = key.device;
  if (selected.has(di)) selected.delete(di); else selected.add(di);

  updateSliderState();

  // 同じデバイスに割り当てられている全ラベルの背景を更新
  for (const l in labelToElement){
    if (labelToKey[l] && labelToKey[l].device === di) updateKeyBg(l);
  }

  // 選択中のデバイス番号 -> ラベル に変換してログ出力
  const deviceToLabel = {};
  for (const l in labelToKey){
    const k = labelToKey[l];
    if (k && k.device !== undefined) deviceToLabel[k.device] = l;
  }
  const selNames = Array.from(selected).map(i => deviceToLabel[i] || `#${i}`);
  log(selNames.length ? `選択: ${selNames.join(',')}` : '選択: 選択なし');
}

function clearSelection(){
  selected.clear();
  updateSliderState();
  for (const l in labelToElement) updateKeyBg(l);
  log('選択: 選択なし');
}
btnClear.addEventListener('click', clearSelection);

function updateSliderState(){
  if (selected.size===0){ selectionInfoEl.textContent=''; slider.disabled=true; slider.value=0; }
  else{ const vals = Array.from(selected).map(i=>deviceValues[i]); const avg = Math.round(vals.reduce((a,b)=>a+b,0)/vals.length); selectionInfoEl.textContent=`${avg}`; slider.disabled=false; slider.value=avg; }
}
slider.addEventListener('input', e=>{ const v = Number(e.target.value); for (const di of selected){ deviceValues[di]=v; for (const lbl in labelToKey) if (labelToKey[lbl].device===di) labelToElement[lbl].val.textContent = String(v); } updateSliderState(); });

/* ===== Web Serial helpers ===== */
let port = null, reader = null;
let serialListeners = [];
function addSerialListener(matcher, timeoutMs=10000){
  return new Promise((resolve,reject)=>{
    const obj = {matcher, resolve, reject};
    if (timeoutMs>0) obj.timer = setTimeout(()=>{ const idx = serialListeners.indexOf(obj); if (idx>=0) serialListeners.splice(idx,1); reject(new Error('timeout')); }, timeoutMs);
    serialListeners.push(obj);
  });
}
function notifySerialLine(line){
  for (let i=serialListeners.length-1;i>=0;--i){
    const o = serialListeners[i];
    try{ if (o.matcher(line)){ if (o.timer) clearTimeout(o.timer); o.resolve(line); serialListeners.splice(i,1);} }catch(e){}
  }
}
async function startReadLoop(){
  if (!port) return;
  const textDecoder = new TextDecoderStream();
  port.readable.pipeTo(textDecoder.writable);
  reader = textDecoder.readable.getReader();
  let buf = '';
  try{
    while (true){
      const {value, done} = await reader.read();
      if (done) break;
      if (value){
        buf += value;
        let idx;
        while ((idx = buf.indexOf('\n'))>=0){
          const line = buf.slice(0, idx+1).trim(); buf = buf.slice(idx+1);
          if (line.length>0){ log('[RX] '+line); notifySerialLine(line); }
        }
      }
    }
  }catch(e){ log('read loop error: '+e); }finally{ if (reader){ try{ await reader.cancel(); }catch(e){} reader=null; } log('read loop finished'); }
}
async function writeSerial(txt){
  if (!port) throw new Error('port not open');
  const encoder = new TextEncoder();
  const w = port.writable.getWriter();
  await w.write(encoder.encode(txt + '\n'));
  w.releaseLock();
  log('[TX] '+txt);
}

/* friendly port info */
function friendlyFromInfo(info){
  if (!info) return 'USB Serial';
  const vid = info.usbVendorId, pid = info.usbProductId;
  if (!vid) return 'USB Serial';
  const vendor = VENDOR_MAP[vid] || ('VID:0x'+vid.toString(16));
  const prod = pid ? (' PID:0x'+pid.toString(16)) : '';
  return vendor + prod;
}

/* ===== Connect/Disconnect flows ===== */
btnConnect.addEventListener('click', async ()=>{
  if (!('serial' in navigator)){ alert('Web Serial API is not available in this browser. Use Chrome/Edge.'); return; }
  try{
    port = await navigator.serial.requestPort();
    const baud = parseInt(baudInput.value || '115200', 10);
    await port.open({ baudRate: baud });
    statusEl.textContent = 'Connected';
    let info = null; try{ info = port.getInfo(); }catch(e){}
    portInfoEl.textContent = 'Port: ' + friendlyFromInfo(info);
    btnConnect.disabled=true; btnDisconnect.disabled=false;
    startReadLoop();
    try{ await writeSerial('HELLO'); await addSerialListener(l=>l.trim().toUpperCase().startsWith('READY'), 3000); log('Device READY'); statusEl.textContent = 'Device READY'; }catch(e){ log('READY not received (timeout)'); }
  }catch(err){ log('Connect error: '+err); statusEl.textContent = 'Not connected'; if (port){ try{ await port.close(); }catch(e){} port=null; } }
});

btnDisconnect.addEventListener('click', async ()=>{
  try{
    if (reader){ try{ await reader.cancel(); }catch(e){} reader=null; }
    if (port && port.readable){ try{ await port.readable.cancel(); }catch(e){} }
    if (port && port.writable){ try{ const w = port.writable.getWriter(); await w.close(); }catch(e){} }
    if (port){ await port.close(); port=null; }
    statusEl.textContent = 'Disconnected'; portInfoEl.textContent='Port: -'; btnConnect.disabled=false; btnDisconnect.disabled=true; log('Disconnected');
  }catch(e){ log('Disconnect err: '+e); }
});

/* ===== Run sequence (sequential) ===== */
btnRun.addEventListener('click', async ()=>{
  if (!port) { alert('Not connected'); return; }
  if (running) { log('Already running'); return; }
  running = true; stopRequested=false;
  btnStop.disabled=false; btnRun.disabled=true; btnConnect.disabled=true; btnDisconnect.disabled=true;
  try{
    for (let idx=0; idx<N_DEVICES; idx++){
      if (stopRequested){ log('Stop requested'); break; }
      const val = deviceValues[idx] || 0;
      const steps = Math.floor(STEPS_PER_REV * val / 100);
      if (steps<=0){ log(`Unit ${idx+1} skip`); continue; }
      const delay_s = MIN_STEP_DELAY + (1 - val/100.0) * (MAX_STEP_DELAY - MIN_STEP_DELAY);
      const delay_ms = Math.max(1, Math.round(delay_s*1000));
      currentDevice = idx; for (const lbl in labelToElement) updateKeyBg(lbl);
      await writeSerial(`RUN ${idx} ${steps} ${delay_ms}`);
      try{
        const line = await addSerialListener(l=>{
          const p = l.trim().split(/\s+/); if (!p.length) return false;
          const k = p[0].toUpperCase();
          if ((k==='DONE' || k==='STOPPED') && p.length>=2) return Number(p[1])===idx;
          if (k==='ERROR') return true; return false;
        }, Math.max(5000, steps*delay_ms + 5000));
        log('[Dev] '+line);
        const parts = line.trim().split(/\s+/); const k = parts[0].toUpperCase();
        if (k==='STOPPED'){ log(`Unit ${idx+1} stopped`); break; }
        if (k==='ERROR'){ log(`Unit ${idx+1} error: ${line}`); break; }
      }catch(e){ log('Wait DONE timeout: '+e); break; }finally{ currentDevice=-1; for (const lbl in labelToElement) updateKeyBg(lbl); }
    }
    log('Run finished');
  }catch(e){ log('Run error: '+e); }
  running=false; btnStop.disabled=true; btnRun.disabled=false; btnConnect.disabled=true; btnDisconnect.disabled=false;
});

btnStop.addEventListener('click', async ()=>{ stopRequested=true; if (!port){ log('No port'); return; } try{ await writeSerial('STOP'); log('STOP sent'); }catch(e){ log('STOP send err: '+e); } });

/* init */
buildKeyboard(); updateSliderState();
log('Ready. Use Connect (Chrome/Edge).');
if (!('serial' in navigator)) { log('Web Serial API not available. Use Chrome/Edge.'); alert('Web Serial API not available in this browser.'); }
</script>
</body>
</html>

